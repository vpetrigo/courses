В данной задаче от вас потребуется реализовать аналоги популярной концепции [MapReduce](https://ru.wikipedia.org/wiki/MapReduce) в терминах потоков.

Напишите функцию `map_reduce`, которая принимает на вход:

- итератор на начало последовательности,
- итератор на конец последовательности,
- унарный функтор, который можно применить к элементам последовательности,
- бинарный функтор, который можно применить к результатам применения первого функтора,количество потоков.

### Результат вызова map_reduce

```cpp
auto res = map_reduce(p, q, f1, f2, num);
```

должен быть эквивалентен результату следующего кода:

```cpp
auto res = f1(*p);
while(++p != q)
    res = f2(res, f1(*p));
```

только выполнение этого кода должно быть разбито на `num` потоков. Для этого можно разбить диапазон `[p,q)` на num частей, выполнить вычисление для каждой части в отдельном потоке и объединить результаты из всех потоков.

### Пример:

```cpp
std::list<int> l = {1,2,3,4,5,6,7,8,9,10};
// параллельное суммирование в 3 потока
auto sum = map_reduce(l.begin(), l.end(), 
             [](int i){return i;}, 
                      std::plus<int>(), 3);

// проверка наличия чётных чисел в четыре потока
auto has_even = map_reduce(l.begin(), l.end(), 
                 [](int i){return i % 2 == 0;}, 
                std::logical_or<bool>(), 4);
```

### Гарантии:

- Длина последовательности не меньше количества потоков.
- Функция f2 ассоциативна.

### Требования:

- Реализовать map_reduce нужно с использование std::async.
- Функция не должна изменять или копировать последовательность.
- У потоков не должно быть разделяемых неконстантных данных (соответственно, не нужны примитивы синхронизации).

*Замечание:* по техническим причинам решение не должно быть рекурсивным.