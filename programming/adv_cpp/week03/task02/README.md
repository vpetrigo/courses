На первой неделе мы [познакомились][1] с RTTI и понятием мультиметодов. В этой задаче предлагается реализовать шаблонный класс Multimethod2, реализующий мультиметод от двух аргументов, который позволяет динамически добавлять новые реализации мультиметода для различных пар классов.

Вам нужно будет реализовать три метода класса Multimethod2:
- `addImpl` — добавляет реализацию мультиметода для двух типов, которые заданы через `std::type_info`.
- `hadImpl` — принимает два указателя и проверяет, есть ли реализация мультиметода для соответствующих типов.
- `call` — принимает два указателя и вызывает для них соответствующую реализацию.
Реализация этих методов должна корректно обрабатывать ситуацию, когда мультиметод является коммутативным (т.е. если результат вызова мультиметода не зависит от порядка аргументов).

Пример использования:

```cpp
// базовый класс фигуры (полиморфный)
struct Shape { ... };

// прямоугольник
struct Rectangle : Shape { ... };

// треугольник
struct Triangle : Shape { ... };

// функция для проверки пересечения двух прямоугольников
bool is_intersect_r_r(Shape * a, Shape * b);

// функция для проверки пересечения прямоугольника и треугольника
bool is_intersect_r_t(Shape * a, Shape * b);

int main() 
{
    // мультиметод для наследников Shape
    // возращающий bool и являющийся коммутативным 
    Multimethod2<Shape, bool, true> is_intersect;

    // добавляем реализацию мультиметода для двух прямоугольников
    is_intersect.addImpl(typeid(Rectangle), typeid(Rectangle), is_intersect_r_r);

    // добавляем реализацию мультиметода для прямоугольника и треугольника
    is_intersect.addImpl(typeid(Rectangle), typeid(Triangle), is_intersect_r_t);

    // создаём две фигуры    
    Shape * s1 = new Triangle();
    Shape * s2 = new Rectangle();

    // проверяем, что реализация для s1 и s2 есть
    if (is_intersect.hasImpl(s1, s2))
    {
         // вызывается функция is_intersect_r_t(s2, s1)
         bool res = is_intersect.call(s1, s2);

         // Замечание: is_intersect_r_t ожидает,
         // что первым аргументом будет прямоугольник
         // а вторым треугольник, а здесь аргументы
         // передаются в обратном порядке. 
         // ваша реализация должна самостоятельно 
         // об этом позаботиться
    }
}
```

Для реализации вам потребуется положить `std::type_info` в какой-то контейнер. Однако по стандарту `std::type_info` нельзя копировать, поэтому просто так его в контейнер не положить. Для решения этой проблемы в новом стандарте появился специальный класс-обёртка `std::type_index`, который можно хранить в контейнерах и даже использовать в качестве ключа в упорядоченных ассоциативных контейнерах. `std::type_index` определён в заголовочном файле `<typeindex>`.

Дополнительную информацию вы найдёте в шаблоне кода.

[1]: https://stepik.org/lesson/53367/step/7?unit=31461