На предыдущем степе в условной спецификации noexcept мы воспользовались тем, что функция `swap` имеет аргументы нужных нам типов. В тех случаях, когда аргументов нужного типа у функции нет, можно использовать `std::declval<T>()`, который позволяет "определить" значение типа `T` в различных контекстах, в т.ч. в `noexcept`.

Специфицируйте noexcept для шаблонной функции do_math, если известно, что в её реализации значения типа `T` копируются,  присваиваются и складываются при помощи оператора +.

Для простоты будем считать, что перемещающих методов у типа `T` нет.

**Пример**:

```cpp
bool b1 = noexcept(do_math<int>()); // true

bool b2 = noexcept(do_math<std::string>()); // false
```

_Hint_: в данном задании вполне можно обойтись `std::declval<T>()`, но при желании можно так же заглянуть в библиотеку поддержки типов и найти там подходящую проверку.