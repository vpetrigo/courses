Тяжелое задание этой недели. Реализовать **Wait/Die** блокировки,
которые позволяют избежать deadlock-ов.

Решать это задание можно только на языке C. Вам будут доступны
блокировки (`struct lock`), переменные состояния (`struct condition`)
и атомарные Read/Modify/Write регистры (`atomic_int`, `atomic_uint`,
`atomic_short`, `atomic_ushort`, `atomic_long`, `atomic_ulong`, `atomic_llong`,
`atomic_ullong`) с интерфейсом, который использовался в видео.

Проверяющая система будет оценивать вашу реализацию на ряде простых однопоточных тестов:

- если только один поток пытается захватить блокировку, то захват должен быть успешным
- попытка захвата одной блокировки несколько раз из одного потока не должна приводить к deadlock-у

Кроме простых однопоточных тестов, естественно, будет и многопоточный:
несколько потоков будут пытаться захватить блокировки в таком порядке,
который с большой вероятностью приведет к deadlock-у. Если ваше решение
не укладывается в лимит времени, значит в вашем коде скорее всего случился deadlock.

Требуемый интерфейс реализации описан в шаблоне кода.